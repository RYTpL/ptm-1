# определяем функции для 20 математических операций
def add(x, y):
    # возвращает сумму двух чисел
    return x + y
def sub(x, y):
    # возвращает разность двух чисел
    return x - y
import math
def mul(x, y):
    # возвращает произведение двух чисел
    return x * y

def div(x, y):
    # возвращает частное двух чисел
    return x / y



def mod(x,y):
    # возвращает остаток от деления двух чисел
    return x%y

def pow(x, y):
    # возвращает x в степени y
    return x**y

def sqrt(x):
    # возвращает квадратный корень из x
    return math.sqrt(x)
def log(x, base):
    # возвращает логарифм x по основанию base
    return math.log(x, base)
def sin(x):
    # возвращает синус угла x в радианах
    return math.sin(x)



def cos(x):
    # возвращает косинус угла x в радианах
    return math.cos(x)
def tan(x):
    # возвращает тангенс угла x в радианах
    return math.tan(x)

def asin(x):
    # возвращает арксинус x в радианах
    return math.asin(x)



# импортируем библиотеку для работы с web страницами
import requests
# импортируем библиотеку для парсинга html
from bs4 import BeautifulSoup

"""
def emails(link)->None:
# задаем url страницы
    url = link
    # получаем содержимое страницы
    response = requests.get(url)
    # проверяем, что запрос успешен
    if response.status_code == 200:
        # преобразуем содержимое в объект BeautifulSoup
        soup = BeautifulSoup(response.text, "html.parser")
        # ищем все блоки <p> с class = "email"
        email_blocks = soup.find_all("p", class_="email")
        # создаем пустой список для хранения email
        email_list = []
        # проходим по каждому блоку
        for block in email_blocks:
            # извлекаем текст из блока
            email = block.get_text()
            # находим индекс символа ":"
            index = email.find(":")
            # если индекс не равен -1, то есть символ ":" есть в тексте
            if index != -1:
                # добавляем в список текст, который идет после ":", удаляя лишние пробелы и табы с помощью метода strip()
                email_list.append(email[index+1:].strip())
        # выводим на экран список email
        for i in email_list:
            print(i,"\n")
    else:
        # если запрос не успешен, выводим код ошибки
        print(f"Ошибка: {response.status_code}")
"""

def acos(x):
    # возвращает арккосинус x в радианах
    return math.acos(x)

def atan(x):
    # возвращает арктангенс x в радианах
    return math.atan(x)

def exp(x):
    # возвращает экспоненту x, то есть e в степени x
    return math.exp(x)



def fac(x):
    # возвращает факториал x, то есть произведение всех натуральных чисел от 1 до x
    return math.factorial(x)

def gcd(x,
         y):
    # возвращает наибольший общий делитель двух чисел
    return math.gcd(x,y)

def lcm(x,y):
    # возвращает наименьшее общее кратное двух чисел
    return (x*y) // math.gcd(x,y)

def rad(deg):
    # конвертирует градусы в радианы


    return deg * math.pi / 180
def deg(rad):
    # конвертирует радианы в градусы
    return rad*180/math.pi

# добавляем функцию для решения квадратных уравнений вида ax^2 + bx + c = 0
def solve(a, b, c):
    # проверяем, что a не равно нулю
    if a == 0:
        print("Это не квадратное уравнение.")
        return
    # вычисляем дискриминант
    d = sub(pow(b, 2), mul(4, mul(a, c)))
    # проверяем знак дискриминанта
    if d > 0:
        # два вещественных корня
        x1 = div(sub(-b, sqrt(d)), mul(2, a))
        x2 = div(add(-b, sqrt(d)), mul(2, a))
        print(f"Уравнение имеет два корня: x1 = {x1}, x2 = {x2}")
    elif d == 0:
        # один вещественный корень
        x = div(-b, mul(2, a))
        print(f"Уравнение имеет один корень: x = {x}")
    else:
        # два комплексных корня
        re = div(-b, mul(2, a)) # действительная часть
        im = div(sqrt(-d), mul(2, a)) # мнимая часть
        print(f"Уравнение имеет два комплексных корня: x1 = {re} + {im}i, x2 = {re} - {im}i")

# добавляем функцию для решения кубических уравнений вида ax^3 + bx^2 + cx + d = 0
def solve_cubic(a, b, c, d):
    # проверяем, что a не равно нулю
    if a == 0:
        print("Это не кубическое уравнение.")
        return
    # приводим уравнение к виду x^3 + px + q = 0 с помощью замены x = y - b / (3a)
    p = div(sub(mul(3, mul(a, c)), pow(b, 2)), mul(3, pow(a, 2)))
    q = div(sub(mul(2, pow(b, 3)), mul(9, mul(a, mul(b, c))) , mul(27, mul(a, mul(a, d)))), mul(27, pow(a, 3)))
    # вычисляем дискриминант
    D = sub(div(pow(q, 2), 4), div(pow(p, 3), 27))
    # проверяем знак дискриминанта
    if D > 0:
        # один вещественный корень и два комплексных корня
        alpha = div(add(-q, sqrt(D)), 2)
        beta = div(sub(-q, sqrt(D)), 2)
        A = pow(alpha, div(1, 3)) # кубический корень из alpha
        B = pow(beta, div(1, 3)) # кубический корень из beta
        x1 = sub(add(A, B), div(b, mul(3, a))) # вещественный корень
        re = sub(-div(add(A, B), 2), div(b, mul(3, a))) # действительная часть комплексных корней
        im = mul(div(sqrt(3), 2), sub(A, B)) # мнимая часть комплексных корней
        x2 = f"{re} + {im}i" # первый комплексный корень
        x3 = f"{re} - {im}i" # второй комплексный корень
        print(f"Уравнение имеет один вещественный корень и два комплексных корня: x1 = {x1}, x2 = {x2}, x3 = {x3}")
    elif D == 0:

        # три вещественных корня, из которых два равны
        A = pow(div(-q ,2), div(1 ,3)) # кубический корень из -q / 2

        x1 = sub(mul(2 ,A), div(b ,mul(3 ,a))) # первый вещественный корень
        x2 = sub(-A ,div(b ,mul(3 ,a))) # второй и третий вещественные корни (равны)

        print(f"Уравнение имеет три вещественных корня, из которых два равны: x1 = {x1}, x2 = x3 = {x2}")
    else:
        # три различных вещественных корня
        phi = acos(div(-q ,mul(2 ,sqrt(div(-pow(p ,3) ,27))))) # угол phi в радианах
        r = sqrt(div(-p ,3)) # радиус окружности

        x1 = sub(mul(2 ,mul(r ,cos(div(phi,3)))), div(b ,mul(3 ,a))) # первый вещественный корень
        x2 = sub(mul(2 ,mul(r ,cos(div(add(phi ,mul(2 ,math.pi)) ,3)))), div(b ,mul(3 ,a))) # второй вещественный корень
        x3 = sub(mul(2 ,mul(r ,cos(div(sub(phi,mul(2 ,math.pi)) ,3)))), div(b ,mul(3 ,a))) # третий вещественный корень
        print(f"Уравнение имеет три различных вещественных корня: x1 = {x1}, x2 = {x2}, x3 = {x3}")

# добавляем функцию для визуализации квадратного уравнения вида ax^2 + bx + c = 0
def plot_quadratic(a, b, c):
    # импортируем модули numpy и matplotlib
    import numpy as np
    import matplotlib.pyplot as plt
    # создаем массив значений x в диапазоне от -10 до 10 с шагом 0.1
    x = np.arange(-10, 10, 0.1)
    # вычисляем значения y как ax^2 + bx + c
    y = a * x**2 + b * x + c
    # создаем объект графика
    fig, ax = plt.subplots()
    # рисуем кривую y по x
    ax.plot(x, y)
    # добавляем подписи к осям и заголовок графика
    ax.set_xlabel( "x" )
    ax.set_ylabel("y")
    ax.set_title(f"График квадратного уравнения {a}x^2 + {b}x + {c} = 0")
    # показываем график на экране
    plt.show()

# добавляем функцию для визуализации кубического уравнения вида ax^3 + bx^2 + cx + d = 0
def plot_cubic(a, b, c, d):
    # импортируем модули numpy и matplotlib
    import numpy as np
    import matplotlib.pyplot as plt
    # создаем массив значений x в диапазоне от -10 до 10 с шагом 0.1
    x = np.arange(-10, 10, 0.1)
    # вычисляем значения y как ax^3 + bx^2 + cx + d
    y = a * x**3 + b * x**2 + c * x + d
    # создаем объект графика
    fig, ax = plt.subplots()
    # рисуем кривую y по x
    ax.plot(x, y)
    # добавляем подписи к осям и заголовок графика
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_title(f"График кубического уравнения {a}x^3 + {b}x^2 + {c}x + {d} = 0")
    # показываем график на экране
    plt.show()

# добавляем функцию для перевода числа в двоичную систему счисления
def decimal_to_binary(number):
    # проверяем, что число целое и неотрицательное
    if not isinstance(number, int) or number < 0:
        print("Неверный формат числа. Введите целое неотрицательное число.")
        return
    # создаем пустую строку для хранения двоичного представления
    binary = ""
    # если число равно нулю, то возвращаем "0"
    if number == 0:
        return "0"
    # иначе делим число на 2 и добавляем остаток в начало строки
    else:
        while number > 0:
            binary = str(number % 2) + binary
            number = number // 2
        # возвращаем полученную строку
        return binary
# добавляем функцию для перевода десятичной дроби в обычную
def decimal_to_fraction(decimal):
    # импортируем модуль fractions
    from fractions import Fraction
    # преобразуем десятичное число в объект Fraction с помощью метода from_decimal
    fraction = Fraction.from_decimal(decimal)
    # возвращаем объект Fraction в виде строки
    return str(fraction)


# создаем словарь для хранения названий и ссылок на функции
functions = {
"сложение": add,
"вычитание": sub,
"умножение": mul,
"деление": div,
"остаток": mod,
"степень": pow,
"корень": sqrt,
"логарифм": log,
"синус": sin,
"косинус": cos,
"тангенс": tan,
"арксинус": asin,
"арккосинус": acos,
"арктангенс": atan,
"экспонента": exp,
"факториал": fac,
"НОД": gcd,
"НОК": lcm,
"радианы": rad,
"градусы": deg
}

# создаем список для хранения названий функций в порядке вывода меню
menu = ["сложение","вычитание","умножение","деление","остаток","степень","корень","логарифм","синус","косинус","тангенс","арксинус","арккосинус","арктангенс","экспонента","факториал","НОД","НОК","радианы","градусы"]

# создаем функцию для вывода меню и ввода выбора пользователя
def choose():
    # выводим приветствие
    print("Добро пожаловать в программу для вычисления математических операций!")
    # выводим меню с нумерацией функций
    print("Выберите одну из следующих функций:")
    for i in range(len(menu)):
        print(f"{i + 1}. {menu[i]}")
    # вводим номер выбранной функции
    choice = int(input("Введите номер функции: "))
    # проверяем, что номер в допустимом диапазоне
    while choice < 1 or choice > len(menu):
        print("Неверный номер функции. Попробуйте еще раз.")
        choice = int(input("Введите номер функции: "))
    # возвращаем название выбранной функции
    return menu[choice - 1]
# создаем функцию для ввода аргументов и вычисления результата
def calculate(function):
    # вводим аргументы в зависимости от количества параметров функции
    if function in ["сложение", "вычитание", "умножение", "деление", "остаток", "степень", "логарифм", "НОД", "НОК"]:
        # вводим два аргумента
        x = float(input("Введите первый аргумент: "))
        y = float(input("Введите второй аргумент: "))
        # вычисляем результат
        result = functionsfunction
    elif function in ["корень", "синус", "косинус", "тангенс", "арксинус", "арккосинус", "арктангенс", "экспонента", "факториал", "радианы", "градусы"]:
        # вводим один аргумент
        x = float(input("Введите аргумент: "))
        # вычисляем результат
        result = functionsfunction
    # выводим результат
    print(f"Результат {function} равен {result}")
# создаем переменную для хранения флага продолжения работы программы
continue_flag = True
# запускаем основной цикл программы
while continue_flag:
    # выбираем функцию из меню
    function = choose()
    # вычисляем результат с помощью выбранной функции
    calculate(function)


    # спрашиваем пользователя, хочет ли он продолжить работу программы
    answer = input("Хотите продолжить? (да/нет): ")
    # проверяем ответ пользователя
    if answer.lower() == "нет":
            # меняем флаг на False, чтобы выйти из цикла
            continue_flag = False







# выводим прощание
print("Спасибо за использование программы! До свидания!")
